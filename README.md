# 二叉树算法程序

## 项目简介

本项目实现了一个完整的二叉搜索树(Binary Search Tree, BST)算法程序，使用Java语言编写。提供了二叉树的核心操作，包括插入、删除、查找等基本功能，以及树的遍历、属性计算等辅助功能。

本项目适用于学习和演示二叉树数据结构及其基本算法。

## 项目结构

```
.
├── src/
│   ├── main/java/com/square/binarytree/
│   │   ├── TreeNode.java              # 树节点类
│   │   ├── BinarySearchTree.java      # 二叉搜索树实现类
│   │   └── Main.java                  # 演示程序
│   └── test/java/com/square/binarytree/
│       └── BinarySearchTreeTest.java  # 单元测试类
├── pom.xml                            # Maven配置文件
├── compile.sh                         # 编译脚本
├── run.sh                            # 运行脚本
├── run_tests.sh                      # 测试脚本
└── README.md                         # 本文件
```

## 功能特性

### 核心功能

1. **插入节点 (insert)**
   - 支持插入整数值到二叉搜索树
   - 自动维护BST性质（左小右大）
   - 重复值会被忽略

2. **删除节点 (delete)**
   - 支持删除指定值的节点
   - 正确处理三种删除场景：
     - 删除叶子节点
     - 删除只有一个子节点的节点
     - 删除有两个子节点的节点
   - 删除后自动维护BST性质

3. **查找节点 (search/findNode)**
   - 快速查找指定值是否存在
   - 返回节点对象或布尔值

### 遍历功能

- **前序遍历** (preorderTraversal): 根-左-右
- **中序遍历** (inorderTraversal): 左-根-右 (对BST结果有序)
- **后序遍历** (postorderTraversal): 左-右-根

### 辅助功能

- **获取树的高度** (getHeight): 计算树的最大深度
- **获取节点总数** (getSize): 统计树中节点数量
- **判断是否为空** (isEmpty): 检查树是否为空树
- **清空树** (clear): 清除所有节点
- **打印树结构** (printTree): 可视化显示树的结构
- **统计信息** (getStatistics): 获取树的各项统计数据

## 环境要求

- **JDK**: 8 或更高版本
- **Maven**: 3.6+ (可选，用于依赖管理)
- **JUnit**: 5.9.3 (用于运行测试)

## 快速开始

### 方法一：使用脚本运行

#### 1. 编译项目

```bash
./compile.sh
```

#### 2. 运行演示程序

```bash
./run.sh
```

#### 3. 运行单元测试

```bash
./run_tests.sh
```

### 方法二：使用Maven

#### 1. 编译项目

```bash
mvn clean compile
```

#### 2. 运行演示程序

```bash
mvn exec:java
```

#### 3. 运行单元测试

```bash
mvn test
```

#### 4. 打包项目

```bash
mvn package
```

生成的JAR文件位于 `target/binary-tree-algorithm-1.0.0.jar`

运行JAR包：
```bash
java -jar target/binary-tree-algorithm-1.0.0.jar
```

### 方法三：手动编译和运行

#### 1. 编译源代码

```bash
mkdir -p target/classes
javac -d target/classes -encoding UTF-8 src/main/java/com/square/binarytree/*.java
```

#### 2. 运行主程序

```bash
java -cp target/classes com.square.binarytree.Main
```

## 使用示例

### 基本使用

```java
// 创建二叉搜索树
BinarySearchTree bst = new BinarySearchTree();

// 插入节点
bst.insert(50);
bst.insert(30);
bst.insert(70);
bst.insert(20);
bst.insert(40);

// 打印树结构
bst.printTree();

// 查找节点
boolean found = bst.search(30);  // true
System.out.println("查找30: " + found);

// 获取树的属性
System.out.println("树的高度: " + bst.getHeight());
System.out.println("节点总数: " + bst.getSize());

// 遍历树
List<Integer> inorder = bst.inorderTraversal();
System.out.println("中序遍历: " + inorder);  // [20, 30, 40, 50, 70]

// 删除节点
bst.delete(30);
System.out.println("删除30后的中序遍历: " + bst.inorderTraversal());
```

### 演示程序输出

运行 `./run.sh` 后，你将看到：

```
===========================================
      二叉树算法程序演示
===========================================

【演示1：插入节点】
--------------------------------------
插入节点序列：
50 30 70 20 40 60 80 10 25 35 65 

========== 二叉树结构 ==========
└── 50
    ├── 30
    │   ├── 20
    │   │   ├── 10
    │   │   └── 25
    │   └── 40
    │       └── 35
    └── 70
        ├── 60
        │   └── 65
        └── 80
====================================

【演示2：查找节点】
--------------------------------------
查找值 40: 找到 ✓
查找值 65: 找到 ✓
查找值 100: 未找到 ✗
查找值 10: 找到 ✓

... (更多演示输出)
```

## 测试说明

项目包含全面的单元测试，覆盖以下场景：

### 插入操作测试
- 插入单个节点
- 插入多个节点
- 插入重复值
- 有序插入（退化为链表）

### 查找操作测试
- 空树查找
- 查找存在的节点
- 查找不存在的节点

### 删除操作测试
- 删除叶子节点
- 删除只有一个子节点的节点
- 删除有两个子节点的节点
- 删除根节点
- 删除不存在的节点
- 从空树删除

### 遍历操作测试
- 中序遍历的有序性验证
- 前序遍历
- 后序遍历
- 空树遍历

### 辅助方法测试
- 树的高度计算
- 树的大小计算
- isEmpty方法
- clear方法

### 综合场景测试
- 连续插入和删除
- 边界值测试

运行测试后，你将看到详细的测试报告，包括通过的测试数量、失败的测试等信息。

## 性能分析

### 时间复杂度

| 操作 | 平均情况 | 最坏情况 | 说明 |
|------|---------|---------|------|
| 插入 | O(log n) | O(n) | 平衡树为O(log n)，退化为链表时为O(n) |
| 删除 | O(log n) | O(n) | 同插入 |
| 查找 | O(log n) | O(n) | 同插入 |
| 遍历 | O(n) | O(n) | 需要访问所有节点 |

### 空间复杂度

- 节点存储: O(n)，n为节点总数
- 递归调用栈: O(h)，h为树的高度

### 优化建议

1. **平衡性**: 当前实现是基础的BST，可能会退化为链表。可以扩展为AVL树或红黑树以保持平衡。
2. **迭代实现**: 提供迭代版本的插入、删除、查找方法，避免递归调用栈开销。
3. **泛型支持**: 扩展为支持泛型，不仅限于int类型。

## 设计文档

详细的设计文档请参考：`/home/issuser/文档/codetest_r/ao_test/.qoder/quests/binary-tree-algorithm-design.md`

## 扩展方向

本项目预留了以下扩展点：

1. **支持泛型**: 使TreeNode和BinarySearchTree支持泛型类型
2. **自定义比较器**: 支持自定义比较逻辑
3. **平衡树**: 实现AVL树、红黑树等自平衡二叉搜索树
4. **层序遍历**: 添加广度优先遍历
5. **序列化**: 支持树的序列化和反序列化
6. **可视化**: 图形界面展示树的结构
7. **性能统计**: 添加操作计数和性能分析

## 常见问题

### Q: 为什么有序插入会导致性能下降？

A: 当按照升序或降序插入数据时，BST会退化为链表结构，导致所有操作的时间复杂度从O(log n)变为O(n)。为避免这个问题，可以：
- 随机化插入顺序
- 使用自平衡二叉树（如AVL树、红黑树）

### Q: 如何选择删除节点时的替换策略？

A: 删除有两个子节点的节点时，可以选择：
- 右子树的最小节点（中序后继）- 本实现采用此策略
- 左子树的最大节点（中序前驱）

两种方法都能保持BST性质，选择哪种主要看个人偏好。

### Q: 是否支持重复值？

A: 当前实现忽略重复值的插入。如需支持重复值，可以：
- 在节点中添加计数器
- 允许重复值都插入到右子树

## 贡献指南

欢迎提交Issue和Pull Request来改进本项目！

## 许可证

本项目采用MIT许可证。

## 作者

Binary Tree Algorithm Design Team

## 更新日志

### v1.0.0 (2025-10-28)
- 初始版本发布
- 实现基础的BST操作（插入、删除、查找）
- 实现三种遍历方法（前序、中序、后序）
- 添加辅助功能（高度、大小、打印等）
- 提供完整的单元测试
- 添加演示程序
